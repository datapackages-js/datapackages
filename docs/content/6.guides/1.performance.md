---
title: Best Practices & Performance
description: Optimizing DataPackages for efficiency, memory footprint, and speed.
---

# Best Practices & Performance

DataPackages is designed to be efficient, but how you use it can significantly impact your application's performance and memory footprint.

## 1. Streaming vs. Full Loading

When should you use `@datapackages/plugin-stream`?

| Scenario                     | Recommendation | Why?                                           |
| :--------------------------- | :------------- | :--------------------------------------------- |
| **Small Datasets** (< 1MB)   | Full Loading   | Simpler API, no stream overhead.               |
| **Medium Datasets** (1-10MB) | Either         | Depends on whether you need items immediately. |
| **Large Datasets** (> 50MB)  | **Streaming**  | Avoids loading the entire file into RAM.       |

> [!TIP]
> **Memory Usage**: Streaming allows you to process 1 million records while only keeping a handful in memory at any given time.

## 2. In-Memory Search Indexing

If you are using `@datapackages/plugin-search`, keep in mind that the search index itself takes up memory.
- **Selective Indexing**: Only index the fields you actually need to search on. Don't index large description fields if users only search by name.
- **Depth**: Limit the indexing depth. Deeply nested objects increase the index size exponentially.

## 3. Caching Strategy

The `withCache` plugin is powerful but needs careful configuration.
- **TTL**: Set a reasonable Time-To-Live. If your data updates daily, a 1-hour TTL is safe and keeps the app snappy.
- **Drivers**: Use `IndexedDBDriver` for larger datasets in the browser. `MemoryDriver` is fine for small lookup tables but won't persist across sessions.

### Middleware Order & Runtime Validation
Order matters because each middleware intercepts the results of the one before it in the chain. 

DataPackages now includes **soft runtime validation**. The system only warns you if two middlewares are applied in an order that might cause issues, without forcing you to use them together.

For example, if you apply `withCache()` **before** `withStream()`, the system will issue a warning in the console:
> ⚠️ Middleware "stream" should be applied BEFORE "cache". Check your .use() order.

This is because the `stream` loader must be applied closest to the data source so that the `cache` plugin (further from the source) can correctly intercept the full result.

Always follow the official ordering:
```typescript
// ✅ CORRECT
await dataset
  .use(withStream()) // 1. Source-level (Loader)
  .use(withCache());  // 2. Performance-level (Interceptor)
```

## 4. Resource Management (`dispose`)

Always call `dataset.dispose()` when a component unmounts or a service is no longer needed.
- Stops background polling timers.
- Clears the internal array stack.
- Allows the browser/Node.js to garbage collect the data.

```typescript
// Example in a React component
useEffect(() => {
  service.init();
  return () => service.dispose();
}, []);
```

## 5. O(1) Lookups

Avoid using `.getAll().find(...)` inside loops. Instead:
1. Load the data once.
2. Build a `Map` or a lookup object.
3. Use that for subsequent lookups.

Many DataPackage services (like `CountryService`) now do this internally automatically.
