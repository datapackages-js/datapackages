---
title: Architecture
description: Understanding the core architecture of DataPackages, the Dataset class, and the middleware system.
---

# Architecture

Understanding the core architecture of DataPackages will help you make the most of the ecosystem.

## The `Dataset` Class

At the heart of everything is the `Dataset` class from `@datapackages/dataset`. It is a generic class that manages:

- **Loading**: Fetching data from a source (static JSON, URL, API).
- **State**: Tracking initialization and management of loaded data.
- **Middleware**: A type-safe pipeline for transforming data or adding side effects.
- **Cleanup**: Managing resources via `dispose()`.

```typescript
import { Dataset } from "@datapackages/dataset";

class MyDataset extends Dataset<MyItem> {
  protected async load() {
    return [{ id: 1, name: "Item 1" }];
  }
}

const myDataset = new MyDataset();
await myDataset.init();
const data = await myDataset.getAll();
```

## Middleware

Middleware is where the magic happens. A middleware is a function that can hook into the dataset's lifecycle:

- `onInit`: Called when the dataset initializes.
- `onLoad`: Called after all data is loaded.
- `dispose`: Called when the dataset is disposed.
- `methods`: Can extend the dataset with new methods (e.g., `search()`, `refresh()`).

### Type-Safe Composition

When you use a middleware, the returned dataset type is automatically updated to include the new methods.

```typescript
const ds = await dataset
  .use(withSearch())      // type includes search()
  .use(withLiveUpdate()); // type includes refresh()

// No casting needed!
await ds.search("query");
await ds.refresh();
```

## Drivers

For persistence (caching), we use a **Driver** pattern. This allows the same caching logic to work in memory, local storage, or IndexedDB.
