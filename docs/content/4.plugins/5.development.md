---
title: Plugin Development Guide
description: Learn how to build your own plugins for the DataPackages ecosystem using the middleware interface.
---

# Plugin Development Guide

This guide explains how to build your own plugins for the DataPackages ecosystem.

## Middleware Interface

A plugin must implement the `DatasetMiddleware` interface:

```typescript
export interface DatasetMiddleware<TItem, TMethods = {}> {
  name?: string;     // Unique name for identification
  after?: string[];  // Must be applied AFTER these (closer to source)
  before?: string[]; // Must be applied BEFORE these (closer to user)

  onInit?(dataset: Dataset<TItem>): void | Promise<void>;
  onLoad?(dataset: Dataset<TItem>, data: TItem[]): void | Promise<void>;
  dispose?(dataset: Dataset<TItem>): void | Promise<void>;
  
  /** Methods added to the dataset instance */
  methods?: TMethods & ThisType<Dataset<TItem> & TMethods>;
}
```

## Creating a Simple Logging Plugin

Let's create a plugin that logs whenever the dataset is initialized.

```typescript
import { DatasetMiddleware } from "@datapackages/dataset";

export function withLogger(prefix: string): DatasetMiddleware<any> {
  return {
    onInit(dataset) {
      console.log(`[${prefix}] Initializing dataset...`);
    }
  };
}
```

## Adding Custom Methods (Type-Safe)

To add methods that the user can call directly on the dataset instance, use the `methods` property and `ThisType`.

```typescript
export interface TelemetryMethods {
  getLoadTime(): number;
}

export function withTelemetry(): DatasetMiddleware<any, TelemetryMethods> {
  let startTime: number;
  let loadTime: number = 0;

  return {
    onInit() {
      startTime = Date.now();
    },
    onLoad() {
      loadTime = Date.now() - startTime;
    },
    methods: {
      getLoadTime() {
        // 'this' is correctly typed as Dataset & TelemetryMethods
        return loadTime;
      }
    }
  };
}
```

### How `ThisType` Works
When we define `methods`, we use `TMethods & ThisType<Dataset<TItem> & TMethods>`. This tells TypeScript that inside the functions defined in `methods`, the `this` keyword refers to a combined type of the base `Dataset` and your plugin's methods.

## Intercepting `load()`

If your plugin needs to override how data is loaded (like the `withCache` or `withStream` plugins), you can override the `load` method.

> [!WARNING]
> When you override `load`, the original `load` method is preserved on the instance as `_load`. You should typically call `this._load()` to get the original data.

```typescript
methods: {
  async load() {
    console.log("Intercepting load...");
    // Call the original load method (which may have been renamed to _load)
    const data = await (this as any)._load();
    return data;
  }
}
```

## Best Practices

1. **State Management**: Use variables outside the `methods` object (but inside the plugin factory function) to store private state for that middleware instance.
2. **Idempotency**: Ensure that calling `onInit` multiple times (if it happens) doesn't cause side effects.
3. **Cleanup**: Always implement `dispose()` if your plugin starts timers (`setInterval`), open sockets, or holds large memory buffers.
4. **Order**: 
   - Use `after: ["plugin-name"]` for **strict dependencies** (e.g. "I need this other plugin to be there").
   - Use `before: ["plugin-name"]` for **soft ordering** (e.g. "If this other plugin exists, I should be applied before it").
